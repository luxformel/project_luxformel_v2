<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <script src="/javascript/header.js"></script>

    <script defer src="/themes/themes.js"></script>

    <link rel="stylesheet" id="theme-set" href="/themes/default.css" />
    <link rel="stylesheet" href="/css/reset.css" />

    <link rel="stylesheet" href="/css/main.css" />
    <link rel="stylesheet" href="/css/chapter.css" />

    <script defer src="/javascript/navigator.js"></script>
    <script defer src="/javascript/side-navigator.js"></script>
    <script defer src="/javascript/scroll-button.js"></script>

    <script src="/javascript/mathjax.js"></script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>

    <script defer src="/settings/settings.js"></script>

    <title>Minimierung und Schaltungsentwurf</title>
  </head>
  <body>
    <div class="main-wrapper">
      <h1>Minimierung und Schaltungsentwurf</h1>
      <h2>Vorgehensweise</h2>
      <p>
        Die Vorgehensweise besteht aus einer allgemeinen Ausführung von vier
        Schritten:
      </p>
      <ol>
        <li>
          <p><u>Problemanalyse:</u></p>
          <p>Identifikation der Eingabe- und Ausgabevariablen.</p>
        </li>
        <li>
          <p><u>Wahrheitstabelle:</u></p>
          <p>
            Systematische Erfassung aller Einkombinationen und
            Ausgabekombinationen.
          </p>
        </li>
        <li>
          <p><u>Boolesche Funktion:</u></p>
          <p>Ableitung der Schaltfunktion aus der Wahrheitstabelle.</p>
        </li>
        <li>
          <p><u>Technische Realisierung:</u></p>
          <p>
            Umsetzung der Funktion in eine physikalische Schaltung mit
            Logikgattern.
          </p>
        </li>
      </ol>
      <h2>Normalformen boolescher Funktionen</h2>
      <h3>Wortschatz</h3>
      <ul>
        <li>
          <p>Literal: Variable oder ihre Negation.</p>
        </li>
        <li>
          <p>
            Minterm: Vollständige Konjunktion aller Literale also die
            UND-Verknüpfung.
          </p>
          $$ \prod_{i=0}^{n-1} \sim x_i $$
          <p>
            wobei \( \sim x_i \) für \( x_i \) oder \( \overline{x_i} \) steht
          </p>
        </li>
        <li>
          <p>
            Maxterm: Vollständige Disjunktion aller Literale also die
            ODER-Verknüpfung.
          </p>
          $$ \sum_{i=0}^{n-1} \sim x_i $$
          <p>
            wobei \( \sim x_i \) für \( x_i \) oder \( \overline{x_i} \) steht
          </p>
        </li>
        <li>
          <p>
            Disjunktive Normalform oder DNF: besteht aus der Disjunktion von
            Mintermen.
          </p>
        </li>
        <li>
          <p>
            Konjunktive Normalform oder KNF: besteht aus der Konjunktion von
            Maxtermen.
          </p>
        </li>
      </ul>
      <h2>Ausgezeichnete Normalformen</h2>
      <p>Ausgezeichnete Normalformen sind kanonische Formen:</p>
      <ul>
        <li>
          <p>
            Ausgezeichnete, DNF oder ADNF: Vollständige Summe aller Minterme
          </p>
        </li>
        <li>
          <p>
            Ausgezeichnete, KNF oder AKNF: Vollständiges Produkt aller Maxterme
          </p>
        </li>
      </ul>
      <h2>Minimale Normalformen</h2>
      <p>Minimale Normalformen sind optimierte Darstellungen:</p>
      <ul>
        <li><p>MDNF: Kürzeste mögliche DNF</p></li>
        <li><p>MKNF: Kürzeste mögliche KNF</p></li>
      </ul>
      <h2>Strategische Auswahl</h2>
      <p>
        Die Wahl der Normalform hängt von der Verteilung der Funktionswerte ab:
      </p>
      <ul>
        <li><p>Bei vielen 0en ist die AKNF effizienter</p></li>
        <li><p>Bei vielen 1en ist die ADNF vorteilhafter</p></li>
        <li>
          <p>
            Don't-Care-Terme ermöglichen zusätzliche Optimierungsmöglichkeiten
          </p>
        </li>
      </ul>
      <h2>Verallgemeinerung von De Morgan</h2>
      <h3>Theorem</h3>
      <p>
        Sei \((\mathscr{L}, \land, \lor, \neg, 0, 1)\) eine Boolesche Algebra
        und seien \(a_1, a_2, \dots, a_n \in \mathscr{L}\). Dann gelten:
      </p>
      $$ \neg(a_1 \land a_2 \land \cdots \land a_n) = \neg a_1 \lor \neg a_2
      \lor \cdots \lor \neg a_n $$ $$ \neg(a_1 \lor a_2 \lor \cdots \lor a_n) =
      \neg a_1 \land \neg a_2 \land \cdots \land \neg a_n $$
      <p>In kompakter Schreibweise:</p>
      \[ \neg\left(\bigwedge_{i=1}^n a_i\right) = \bigvee_{i=1}^n \neg a_i \quad
      \text{und} \quad \neg\left(\bigvee_{i=1}^n a_i\right) = \bigwedge_{i=1}^n
      \neg a_i \]
      <h3>Beweis</h3>
      <p>
        Wir beweisen die erste Gleichung mittels vollständiger Induktion über
        \(n\). Der Beweis der zweiten Gleichung verläuft analog. <br />
        Für \(n=2\) erhalten wir die klassischen De Morgan'schen Gesetze:
      </p>
      \[ \neg(a_1 \land a_2) = \neg a_1 \lor \neg a_2 \]
      <p>
        Dies ist ein Axiom beziehungsweise eine grundlegende Eigenschaft jeder
        Booleschen Algebra. <br />Die Behauptung gelte für ein \(n = k \geq 2\),
        das heißt:
      </p>
      \[ \neg\left(\bigwedge_{i=1}^k a_i\right) = \bigvee_{i=1}^k \neg a_i \]
      <p>Wir betrachten den Ausdruck für \(k+1\) Elemente:</p>
      $$ \neg\left(\bigwedge_{i=1}^{k+1} a_i\right) =
      \neg\left(\left(\bigwedge_{i=1}^k a_i\right) \land a_{k+1}\right) $$ $$=
      \neg\left(\bigwedge_{i=1}^k a_i\right) \lor \neg a_{k+1} $$ $$=
      \left(\bigvee_{i=1}^k \neg a_i\right) \lor \neg a_{k+1} $$ $$=
      \bigvee_{i=1}^{k+1} \neg a_i$$
      <p>
        Damit ist die erste Gleichung für alle \(n \geq 2\) bewiesen. <br />
        Der Beweis der zweiten Gleichung erfolgt durch duale Argumentation oder
        durch Anwendung der ersten Gleichung auf die negierten Elemente.
      </p>
      <p class="square">$\square$</p>
      <h2>Erzeugung der Normalformen</h2>
      <p>
        Jede vorgegebene boolesche Funktion (Wertetabelle, Algebraische
        Funktion, Schaltbild) kann eindeutig durch eine ADN oder eine AKN
        dargestellt werden.
      </p>
      <h2>Karnaugh-Veitch-Diagramme, KV-Diagramme</h2>
      <p>
        KV-Diagramme bieten eine visuelle Methode zur Minimierung für 3 bis 4
        Variable. Die Nachbarschaftsbeziehung im Diagramm entspricht der
        logischen Nachbarschaft im Wahrheitsfeld.
      </p>
      <h2>Quine-McCluskey-Algorithmus</h2>
      <p>
        Dieses systematische Verfahren ist für beliebig viele Variablen geeignet
        und algorithmisch implementierbar. Der Algorithmus ist wie folgt:
      </p>
      <ol>
        <li>
          <p><u>Codierung</u></p>
          <p>Minterme werden als Binärzahlen dargestellt</p>
        </li>
        <li>
          <p><u>Gruppierung</u></p>
          <p>Terme werden nach Anzahl der Einsen sortiert</p>
        </li>
        <li>
          <p><u>Verschmelzung</u></p>
          <p>
            Benachbarte Terme werden kombiniert wobei die Differenz genau ein
            Bit ist
          </p>
        </li>
        <li>
          <p><u>Primimplikanten-Identifikation</u></p>
          <p>Nicht kombinierbare Terme werden als Primimplikanten markiert</p>
        </li>
        <li>
          <p><u>Essenzielle Auswahl</u></p>
          <p>Primimplikanten, die eindeutige 1en abdecken, werden ausgewählt</p>
        </li>
        <li>
          <p><u>Minimale Überdeckung</u></p>
          <p>Restliche Abdeckung mit minimaler Anzahl an Primimplikanten</p>
        </li>
      </ol>
    </div>
  </body>
</html>
